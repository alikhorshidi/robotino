# راهنمای جامع راه‌اندازی و برنامه‌نویسی ربات مکانوم چهار چرخ با ESP32 و درایور TB6600

## مقدمه

### هدف از این راهنما

این گزارش یک دستورالعمل جامع، فنی و آموزشی برای دانشجویان جهت راه‌اندازی و کنترل یک ربات مبتنی بر چرخ‌های مکانوم ارائه می‌دهد. این راهنما فراتر از ارائه یک کد نهایی عمل کرده و مبانی نظری کینماتیک ربات، ملاحظات سخت‌افزاری و دلایل انتخاب‌های فنی در پیاده‌سازی نرم‌افزار را به طور کامل تشریح می‌کند. هدف نهایی، توانمندسازی دانشجویان برای درک عمیق سیستم و توسعه مانورهای حرکتی سفارشی است.

### ساختار ربات شما

سیستم مورد بررسی شامل یک شاسی مجهز به چهار چرخ مکانوم (Mecanum) است که هر چرخ توسط یک موتور استپر گیربکس مستقل به حرکت درمی‌آید. هر یک از این موتورها از طریق یک درایور استپر موتور مدل `TB6600` کنترل می‌شود. هسته پردازشی و کنترلی این مجموعه، یک برد توسعه `ESP32` مدل `DOIT DevKit V1` (نسخه 38 پایه) است که وظیفه تولید سیگنال‌های کنترلی لازم برای هر چهار درایور را بر عهده دارد.

### چالش اصلی: کنترل همزمان و دقیق

چالش اساسی در این پروژه، کنترل همزمان و کاملاً هماهنگ چهار موتور استپر است. مانورهای پیچیده ربات مکانوم (مانند حرکت جانبی یا چرخشی) نیازمند آن است که هر چهار موتور با سرعت‌ها و جهت‌های دقیق و مشخصی کار کنند.

استفاده از روش‌های برنامه‌نویسی ساده و مبتنی بر نرم‌افزار، مانند ایجاد پالس‌های کنترلی از طریق حلقه‌های `for` یا استفاده از تابع `delay()` در آردوینو، به سرعت با محدودیت مواجه می‌شود. این رویکردها منجر به تولید سیگنال‌های پالس ناپایدار و نامنظم، معروف به "لرزش" (Jitter) سیگنال، می‌گردند. این لرزش باعث حرکت متناوب، پرسروصدا و غیردقیق موتورها شده و عملاً پردازنده اصلی (`CPU`) را در طول حرکت قفل می‌کند. در چنین شرایطی، اجرای مانورهای سیال و دقیق مکانوم غیرممکن خواهد بود.

### راه‌حل برتر: استفاده از واحد سخت‌افزاری LEDC

راه‌حل فنی ارائه‌شده در این گزارش، بهره‌گیری هوشمندانه از یکی از تجهیزات جانبی (Peripherals) قدرتمند و داخلی میکروکنترلر ESP32، یعنی واحد `LEDC` (مخفف LED Control)، است.

اگرچه این واحد در اصل برای کنترل شدت نور LEDها از طریق سیگنال `PWM` (مدولاسیون عرض پالس) طراحی شده است، ما از قابلیت‌های آن برای تولید سیگنال‌های پالس (`PUL`) مورد نیاز درایورهای استپر موتور به شکلی خلاقانه استفاده خواهیم کرد.

این انتخاب فنی، مزیت حیاتی زیر را به همراه دارد: **تولید پالس‌ها به طور کامل به سخت‌افزار واگذار می‌شود.** این بدان معناست که سیگنال‌های پالس با فرکانس دقیق، پایدار و "بدون اختلال" (glitch-free) تولید می‌شوند، در حالی که پردازنده (`CPU`) کاملاً آزاد است تا به منطق سطح بالاتر، مانند تصمیم‌گیری برای اجرای مانور بعدی یا پردازش داده‌های سنسور، رسیدگی کند. این معماری، کلید دستیابی به کدی است که همزمان "ساده و آموزشی" و "بدون باگ و با کارایی بالا" باشد.

## بخش ۱: مبانی نظری و درک سخت‌افزار (پیش‌نیاز دانشجویان)

### ۱.۱. رمزگشایی درایور استپر موتور TB6600

درایور `TB6600` نقش یک مترجم و تقویت‌کننده حیاتی را ایفا می‌کند. این ماژول، سیگنال‌های کنترلی ضعیف و سطح منطقی (3.3 ولت در مورد ESP32) را دریافت کرده و آن‌ها را به ولتاژ و جریان بالا (که می‌تواند تا 50 ولت و 5 آمپر برسد) مورد نیاز برای راه‌اندازی موتورهای استپر صنعتی تبدیل می‌کند. برای کنترل این درایور، ما تنها با سه پین ورودی اصلی سروکار داریم:

* **`PUL-` / `STEP` (پالس):** این مهم‌ترین پین ورودی است. درایور `TB6600` طوری طراحی شده که به هر لبه‌ی سیگنال (معمولاً لبه بالارونده) که روی این پین دریافت می‌کند، واکنش نشان می‌دهد و موتور را به اندازه یک "گام" (یا میکروگام، بسته به تنظیمات DIP سوئیچ روی درایور) به حرکت درمی‌آورد.
* **`DIR-` (جهت):** این پین، جهت چرخش موتور را تعیین می‌کند. این یک ورودی باینری ساده است؛ به عنوان مثال، اعمال سطح منطقی `HIGH` (3.3 ولت) به این پین، موتور را در جهت ساعتگرد و اعمال سطح `LOW` (0 ولت) آن را در جهت پادساعتگرد به حرکت درمی‌آورد (یا برعکس، بسته به نحوه سیم‌کشی فازهای موتور).
* **`EN-` (فعال‌ساز):** این پین برای فعال یا غیرفعال کردن کل درایور به کار می‌رود. در اکثر درایورهای `TB6600`، این پین به صورت "Active-LOW" عمل می‌کند؛ یعنی اعمال سطح `LOW` (اتصال به GND) درایور را فعال کرده و اعمال سطح `HIGH` آن را غیرفعال (Disable) می‌کند.

**نکته کلیدی برای دانشجویان:** سرعت چرخش موتور استپر، هیچ ارتباطی با "عرض" پالس‌ها یا "Duty Cycle" آن‌ها ندارد. سرعت موتور، تابعی مستقیم و انحصاری از **فرکانس** سیگنال‌های ارسالی به پین `PUL` است. فرکانس بالاتر (تعداد پالس‌های بیشتر در هر ثانیه) به معنای سرعت چرخش بیشتر موتور است.

### ۱.۲. آناتومی برد DOIT ESP32 DevKit V1 (38-pin)

برد ESP32 به دلیل معماری دو هسته‌ای قدرتمند و مجموعه‌ای غنی از تجهیزات جانبی سخت‌افزاری، انتخابی ایده‌آل برای کاربردهای رباتیک است. پین‌های ارائه‌شده توسط شما (جلو-راست: 32, 33, 25؛ جلو-چپ: 26, 27, 13؛ عقب-راست: 18, 19, 21؛ عقب-چپ: 4, 16, 17) به دقت بررسی شده‌اند.

تحلیل این پین‌ها نشان می‌دهد که انتخاب آن‌ها کاملاً ایمن و صحیح است:

* هیچ‌کدام از پین‌های انتخابی در گروه پین‌های "فقط ورودی" (Input-Only) مانند `GPIO 34, 35, 36, 39` قرار ندارند.
* هیچ‌کدام از پین‌ها جزو پین‌های رزرو شده برای اتصال به حافظه فلش داخلی (`GPIO 6` تا `11`) که استفاده از آن‌ها ممنوع است، نیستند.
* پین `GPIO 4` به عنوان یکی از "Strapping Pins" شناخته می‌شود. این پین‌ها وضعیت خود را در لحظه بوت شدن سیستم تعیین می‌کنند. با این حال، استفاده از `GPIO 4` به عنوان یک پین خروجی پس از اتمام فرآیند بوت شدن، کاملاً استاندارد و بدون مشکل است.

### ۱.۳. کینماتیک چرخ‌های مکانوم: جادوی حرکت همه‌جانبه

برخلاف چرخ‌های معمولی، چرخ‌های مکانوم دارای غلتک‌های کوچکی هستند که با زاویه 45 درجه نسبت به محور اصلی چرخ قرار گرفته‌اند. این طراحی منحصربه‌فرد باعث می‌شود که نیروی رانش اعمال شده توسط موتور، به دو مؤلفه تجزیه شود: یک مؤلفه طولی (در راستای ربات) و یک مؤلفه عرضی (عمود بر راستای ربات).

**قانون چیدمان "X":** برای دستیابی به حرکت همه‌جانبه (Holonomic)، چیدمان چرخ‌ها باید از یک الگوی خاص پیروی کند. هنگامی که از بالا به ربات نگاه می‌کنید، غلتک‌های روی چرخ‌ها باید یک الگوی "X" را تشکیل دهند؛ به این معنی که غلتک‌های چرخ‌های جلو-راست و عقب-چپ، و همچنین چرخ‌های جلو-چپ و عقب-راست، باید در یک راستا باشند و به سمت مرکز ربات اشاره کنند.

**جدول منطقی حرکت:** با کنترل جهت چرخش هر یک از چهار موتور، می‌توان برآیند بردارهای نیرو را طوری تنظیم کرد که ربات به هر جهت دلخواهی حرکت کند. این "نقشه راه" نرم‌افزاری ما است که مستقیماً از سنتز منابع معتبر [1] به دست آمده و در جدول ۱ خلاصه شده است.

#### جدول ۱: نگاشت جهت موتورها برای مانورهای اصلی

| مانور ربات | موتور جلو-راست (FR) | موتور جلو-چپ (FL) | موتور عقب-راست (RR) | موتور عقب-چپ (RL) | توضیحات (بر اساس [1]) |
| :--- | :---: | :---: | :---: | :---: | :--- |
| **جلو (Forward)** | FORWARD | FORWARD | FORWARD | FORWARD | همه موتورها به جلو می‌چرخند؛ نیروهای جانبی یکدیگر را خنثی می‌کنند. |
| **عقب (Backward)** | BACKWARD | BACKWARD | BACKWARD | BACKWARD | همه موتورها به عقب می‌چرخند؛ نیروهای جانبی یکدیگر را خنثی می‌کنند. |
| **حرکت جانبی چپ (Strafe Left)** | BACKWARD | FORWARD | FORWARD | BACKWARD | موتورهای قطری مخالف هم می‌چرخند. نیروهای طولی خنثی شده و نیروهای جانبی با هم جمع می‌شوند. |
| **حرکت جانبی راست (Strafe Right)** | FORWARD | BACKWARD | BACKWARD | FORWARD | دقیقاً برعکس حالت حرکت جانبی به چپ. |
| **چرخش پادساعتگرد (Rotate CCW)** | BACKWARD | FORWARD | BACKWARD | FORWARD | چرخ‌های سمت چپ به جلو و چرخ‌های سمت راست به عقب می‌روند و گشتاور چرخشی ایجاد می‌کنند. |
| **چرخش ساعتگرد (Rotate CW)** | FORWARD | BACKWARD | FORWARD | BACKWARD | چرخ‌های سمت راست به جلو و چرخ‌های سمت چپ به عقب می‌روند. |

**توجه:** در این جدول، `FORWARD` به معنای جهتی است که چرخ برای حرکت ربات به سمت جلو می‌چرخد و `BACKWARD` برعکس آن است.

## بخش ۲: معماری نرم‌افزار: یک رویکرد آموزشی و پایدار

### ۲.۱. چرا از کتابخانه AccelStepper استفاده نمی‌کنیم؟

کتابخانه‌های رایج کنترل استپر مانند `Stepper` (داخلی آردوینو) یا `AccelStepper` (یک کتابخانه محبوب) ابزارهای قدرتمندی هستند. با این حال، معماری آن‌ها ذاتاً مبتنی بر "پالس‌دهی نرم‌افزاری" (Software Pulsing) است. این کتابخانه‌ها برای عملکرد صحیح (به‌ویژه برای دستیابی به شتاب‌دهی)، نیازمند آن هستند که تابع `run()` یا `runSpeed()` آن‌ها به صورت مداوم و با فرکانس بسیار بالا در داخل تابع اصلی `loop()` فراخوانی شود.

این معماری با هدف آموزشی این پروژه که نیازمند یک دموی ساده با استفاده از `delay(5000)` است، در تضاد کامل قرار دارد. اگر در `loop()` از `delay()` استفاده شود، فراخوانی `run()` متوقف شده، پالس‌دهی قطع گردیده و موتورها از حرکت باز می‌ایستند. بنابراین، این کتابخانه‌ها برای سناریوی درخواستی ما مناسب نیستند.

### ۲.۲. معماری انتخابی: قدرت سخت‌افزار LEDC

ما از واحد سخت‌افزاری `LEDC` در ESP32 برای تولید پالس‌های `PUL` استفاده می‌کنیم. این فرآیند در چند مرحله ساده انجام می‌شود [2]:

1.  **انتخاب کانال (Channel):** ESP32 دارای 16 کانال PWM سخت‌افزاری مستقل است (در حالت High/Low Speed). ما چهار کانال (مثلاً کانال‌های 0، 1، 2 و 3) را برای چهار پین `PUL` ربات خود رزرو می‌کنیم.
2.  **تنظیم تایمر (Timer Setup):** با استفاده از تابع `ledcSetup(channel, freq, resolution)`، ما یک بار در ابتدای برنامه، پارامترهای اصلی سیگنال را تنظیم می‌کنیم.
    * `channel`: شماره کانالی که پیکربندی می‌کنیم (مثلاً 0).
    * `freq`: این همان **سرعت موتور** ما است. فرکانسی که می‌خواهیم پالس‌ها با آن تولید شوند (مثلاً 2000 هرتز).
    * `resolution`: دقت سیگنال (مثلاً 8 بیت، که معادل بازه 0 تا 255 است).
3.  **اتصال پین (Pin Attach):** با تابع `ledcAttachPin(pin, channel)`، به ESP32 می‌گوییم که سیگنال سخت‌افزاری تولید شده در `channel` (مثلاً 0) را به `pin` فیزیکی (مثلاً GPIO 25) هدایت کند.
4.  **اجرا (Execution):** با تابع `ledcWrite(channel, duty)`، سیگنال را راه‌اندازی یا متوقف می‌کنیم.

### ۲.۳. استفاده از ledcWrite به عنوان سوئیچ روشن/خاموش

این بخش، هسته اصلی معماری ما است. در کاربردهای عادی (مانند کنترل نور LED)، ما مقدار `duty` را در تابع `ledcWrite` به طور مداوم تغییر می‌دهیم تا روشنایی کم و زیاد شود.

اما در کاربرد ما برای استپر موتور، ما از `duty` به عنوان یک سوئیچ روشن/خاموش برای کل قطار پالس (Pulse Train) استفاده می‌کنیم:

* **روشن کردن موتور:** `ledcWrite(channel, 128);`
    (با فرض رزولوشن 8 بیت)، مقدار 128 یک چرخه وظیفه (Duty Cycle) معادل 50% ایجاد می‌کند. این یک موج مربعی کامل است. درایور `TB6600` با دریافت این سیگنال، شروع به دیدن لبه‌های بالارونده با فرکانسی می‌کند که ما در `ledcSetup` (مثلاً 2000Hz) تنظیم کردیم. در نتیجه، موتور با سرعت ثابت شروع به چرخش می‌کند.
* **خاموش کردن موتور:** `ledcWrite(channel, 0);`
    مقدار 0 یک چرخه وظیفه 0% ایجاد می‌کند. این کار سیگنال را به طور کامل متوقف کرده و آن را در سطح `LOW` نگه می‌دارد. هیچ پالس جدیدی تولید نمی‌شود و موتور (در حالی که گشتاور نگهدارنده خود را حفظ کرده) از چرخش باز می‌ایستد.

### ۲.۴. پیامد این معماری: کد ساده، عملکرد بی‌نقص

مزیت شگفت‌انگیز این رویکرد اکنون آشکار می‌شود: از آنجایی که تمام کارهای سنگین مربوط به زمان‌بندی دقیق و تولید پالس توسط واحد سخت‌افزاری `LEDC` (که مستقل از `CPU` کار می‌کند) انجام می‌شود، تابع `loop()` ما کاملاً آزاد است.

ما می‌توانیم با خیال راحت در `loop()` بنویسیم: `moveForward(); delay(5000);`.
در طول این 5 ثانیه، تابع `loop()` متوقف است، اما سخت‌افزار `LEDC` در پس‌زمینه، به طور خستگی‌ناپذیر و با دقت کامل، به ارسال 2000 پالس در هر ثانیه به هر چهار موتور ادامه می‌دهد. این دقیقاً ترکیبی از "عملکرد عالی" و "کد ساده آموزشی" است که برای این پروژه ایده‌آل است.

## بخش ۳: پیاده‌سازی گام به گام کد

در ادامه، بخش‌های مختلف کد را به صورت گام به گام تشریح می‌کنیم. این توضیحات به عنوان راهنمایی برای درک کد کامل در بخش ۴ عمل می‌کنند.

### ۳.۱. بخش اول: تعاریف سراسری و پارامترها (Header)

در این بخش، تمام پین‌های ۱۲ گانه را بر اساس ورودی شما تعریف می‌کنیم. همچنین پارامترهای اصلی LEDC و سرعت موتور را تعریف می‌نماییم.

```cpp
// --- تعریف پین‌های موتور جلو-راست (FR) ---
#define FR_ENABLE_PIN 32
#define FR_DIR_PIN    33
#define FR_PULSE_PIN  25 // پالس این موتور به کانال LEDC 0 متصل می‌شود

// --- تعریف پین‌های موتور جلو-چپ (FL) ---
#define FL_ENABLE_PIN 26
#define FL_DIR_PIN    27
#define FL_PULSE_PIN  13 // پالس این موتور به کانال LEDC 1 متصل می‌شود

// --- تعریف پین‌های موتور عقب-راست (RR) ---
#define RR_ENABLE_PIN 18
#define RR_DIR_PIN    19
#define RR_PULSE_PIN  21 // پالس این موتور به کانال LEDC 2 متصل می‌شود

// --- تعریف پین‌های موتور عقب-چپ (RL) ---
#define RL_ENABLE_PIN 4
#define RL_DIR_PIN    16
#define RL_PULSE_PIN  17 // پالس این موتور به کانال LEDC 3 متصل می‌شود

// --- پارامترهای کنترل سرعت و LEDC ---
// (توضیحات): این فرکانس، سرعت چرخش موتورها را تعیین می‌کند.
// آن را افزایش دهید تا ربات سریع‌تر حرکت کند (مثلاً 4000).
#define STEP_FREQUENCY 2000 // 2000 هرتز (پالس بر ثانیه)

#define LEDC_TIMER_BITS 8 // رزولوشن 8 بیت (بازه 0-255)
// (توضیحات): ما از نصف رزولوشن (128) برای ایجاد موج مربعی 50% استفاده می‌کنیم.
#define LEDC_DUTY_CYCLE (1 << (LEDC_TIMER_BITS - 1)) // معادل 128

// --- تخصیص کانال‌های LEDC ---
#define FR_LEDC_CHANNEL 0
#define FL_LEDC_CHANNEL 1
#define RR_LEDC_CHANNEL 2
#define RL_LEDC_CHANNEL 3

// --- تعاریف جهت برای خوانایی ---
#define FORWARD  HIGH
#define BACKWARD LOW
```

برای جلوگیری از هرگونه تداخل سخت‌افزاری، حیاتی است که هر پین `PUL` به یک کانال `LEDC` انحصاری متصل شود. جدول زیر این تخصیص را به وضوح نشان می‌دهد:

**جدول ۲: نقشه تخصیص کانال‌های سخت‌افزاری LEDC**

| موتور | پین پالس (PUL) | کانال LEDC اختصاصی |
| :--- | :---: | :---: |
| جلو-راست (FR) | `25` | `0` |
| جلو-چپ (FL) | `13` | `1` |
| عقب-راست (RR) | `21` | `2` |
| عقب-چپ (RL) | `4` | `3` |

### ۳.۲. بخش دوم: تابع `setup()` (پیکربندی اولیه)

در `setup()`، ما تمام پین‌ها را به عنوان `OUTPUT` تعریف می‌کنیم، درایورها را با `LOW` کردن پین `EN` فعال می‌کنیم، و مهم‌تر از همه، چهار کانال `LEDC` را پیکربندی و به پین‌های `PUL` متصل می‌نماییم.

```cpp
void setup() {
  Serial.begin(115200);
  Serial.println("آماده‌سازی ربات مکانوم...");

  // تنظیم همه 12 پین به عنوان خروجی
  pinMode(FR_ENABLE_PIN, OUTPUT);
  pinMode(FR_DIR_PIN, OUTPUT);
  pinMode(FR_PULSE_PIN, OUTPUT);
  
  pinMode(FL_ENABLE_PIN, OUTPUT);
  pinMode(FL_DIR_PIN, OUTPUT);
  pinMode(FL_PULSE_PIN, OUTPUT);
  
  pinMode(RR_ENABLE_PIN, OUTPUT);
  pinMode(RR_DIR_PIN, OUTPUT);
  pinMode(RR_PULSE_PIN, OUTPUT);
  
  pinMode(RL_ENABLE_PIN, OUTPUT);
  pinMode(RL_DIR_PIN, OUTPUT);
  pinMode(RL_PULSE_PIN, OUTPUT);

  // (توضیحات): درایورهای TB6600 با LOW شدن پین EN فعال می‌شوند.
  // ما آن‌ها را یک بار در setup فعال می‌کنیم و تا پایان کار فعال نگه می‌داریم.
  digitalWrite(FR_ENABLE_PIN, LOW);
  digitalWrite(FL_ENABLE_PIN, LOW);
  digitalWrite(RR_ENABLE_PIN, LOW);
  digitalWrite(RL_ENABLE_PIN, LOW);

  // --- پیکربندی سخت‌افزار LEDC ---
  // (توضیحات): این بخش، قلب تپنده سیستم است.
  // ما 4 کانال LEDC را با فرکانس و رزولوشن یکسان تنظیم می‌کنیم.
  ledcSetup(FR_LEDC_CHANNEL, STEP_FREQUENCY, LEDC_TIMER_BITS);
  ledcSetup(FL_LEDC_CHANNEL, STEP_FREQUENCY, LEDC_TIMER_BITS);
  ledcSetup(RR_LEDC_CHANNEL, STEP_FREQUENCY, LEDC_TIMER_BITS);
  ledcSetup(RL_LEDC_CHANNEL, STEP_FREQUENCY, LEDC_TIMER_BITS);

  // (توضیحات): در اینجا، هر کانال سخت‌افزاری را به پین فیزیکی پالس متصل می‌کنیم.
  ledcAttachPin(FR_PULSE_PIN, FR_LEDC_CHANNEL);
  ledcAttachPin(FL_PULSE_PIN, FL_LEDC_CHANNEL);
  ledcAttachPin(RR_PULSE_PIN, RR_LEDC_CHANNEL);
  ledcAttachPin(RL_PULSE_PIN, RL_LEDC_CHANNEL);
  
  Serial.println("ربات آماده است. شروع دمو...");
}
```

### ۳.۳. بخش سوم: توابع کنترلی سطح پایین (Core Control)

این توابع به ما اجازه می‌ده دهند تا جهت همه موتورها را یکجا تنظیم کنیم و پالس‌دهی را به صورت هماهنگ آغاز یا متوقف نماییم.

```cpp
// (توضیحات): این تابع جهت چرخش هر چهار موتور را تنظیم می‌کند.
void setMotorDirections(int frDir, int flDir, int rrDir, int rlDir) {
  digitalWrite(FR_DIR_PIN, frDir);
  digitalWrite(FL_DIR_PIN, flDir);
  digitalWrite(RR_DIR_PIN, rrDir);
  digitalWrite(RL_DIR_PIN, rlDir);
}

// (توضیحات): این تابع با ارسال یک موج مربعی 50% (مقدار 128) به هر چهار کانال،
// پالس‌دهی سخت‌افزاری و در نتیجه حرکت موتورها را آغاز می‌کند.
void activateMotors() {
  ledcWrite(FR_LEDC_CHANNEL, LEDC_DUTY_CYCLE);
  ledcWrite(FL_LEDC_CHANNEL, LEDC_DUTY_CYCLE);
  ledcWrite(RR_LEDC_CHANNEL, LEDC_DUTY_CYCLE);
  ledcWrite(RL_LEDC_CHANNEL, LEDC_DUTY_CYCLE);
}

// (توضیحات): این تابع با ارسال Duty Cycle صفر، تولید پالس را متوقف می‌کند.
// موتورها می‌ایستند اما گشتاور نگهدارنده خود را حفظ می‌کنند.
void robotStop() {
  ledcWrite(FR_LEDC_CHANNEL, 0);
  ledcWrite(FL_LEDC_CHANNEL, 0);
  ledcWrite(RR_LEDC_CHANNEL, 0);
  ledcWrite(RL_LEDC_CHANNEL, 0);
}
```

### ۳.۴. بخش چهارم: توابع حرکتی سطح بالا (Abstraction Layer)

اینجا همان جایی است که دانشجویان بیشترین تعامل را خواهند داشت. این توابع، پیچیدگی کینماتیک (جدول ۱) را پنهان کرده و دستورات قابل فهمی مانند `moveForward()` ارائه می‌دهند.

```cpp
// (توضیحات): پیاده‌سازی منطق جدول ۱ برای حرکت به جلو
void moveForward() {
  Serial.println("حرکت به جلو...");
  setMotorDirections(FORWARD, FORWARD, FORWARD, FORWARD);
  activateMotors();
}

// (توضیحات): پیاده‌سازی منطق جدول ۱ برای حرکت به عقب
void moveBackward() {
  Serial.println("حرکت به عقب...");
  setMotorDirections(BACKWARD, BACKWARD, BACKWARD, BACKWARD);
  activateMotors();
}

// (توضیحات): پیاده‌سازی منطق جدول ۱ برای حرکت جانبی به چپ
void strafeLeft() {
  Serial.println("حرکت جانبی به چپ (Strafe Left)...");
  setMotorDirections(BACKWARD, FORWARD, FORWARD, BACKWARD);
  activateMotors();
}

// (توضیحات): پیاده‌سازی منطق جدول ۱ برای حرکت جانبی به راست
void strafeRight() {
  Serial.println("حرکت جانبی به راست (Strafe Right)...");
  setMotorDirections(FORWARD, BACKWARD, BACKWARD, FORWARD);
  activateMotors();
}

// (توضیحات): پیاده‌سازی منطق جدول ۱ برای چرخش ساعتگرد
void rotateClockwise() {
  Serial.println("چرخش ساعتگرد (CW)...");
  setMotorDirections(FORWARD, BACKWARD, FORWARD, BACKWARD);
  activateMotors();
}

// (توضیحات): پیاده‌سازی منطق جدول ۱ برای چرخش پادساعتگرد
void rotateCounterClockwise() {
  Serial.println("چرخش پادساعتگرد (CCW)...");
  setMotorDirections(BACKWARD, FORWARD, BACKWARD, FORWARD);
  activateMotors();
}
```

### ۳.۵. بخش پنجم: تابع `loop()` (سکانس دمو)

در نهایت، تابع `loop()` سکانس نمایشی درخواستی را اجرا می‌کند. توجه کنید که به لطف معماری `LEDC`، استفاده از `delay()` در اینجا کاملاً ایمن است و منجر به توقف پالس‌دهی نمی‌شود.

```cpp
void loop() {
  // 1. حرکت به جلو برای 5 ثانیه
  moveForward();
  delay(5000);

  // توقف 1 ثانیه‌ای بین مانورها
  robotStop();
  delay(1000);

  // 2. حرکت به عقب برای 5 ثانیه
  moveBackward();
  delay(5000);

  robotStop();
  delay(1000);

  // 3. حرکت جانبی به چپ برای 5 ثانیه
  strafeLeft();
  delay(5000);

  robotStop();
  delay(1000);

  // 4. حرکت جانبی به راست برای 5 ثانیه
  strafeRight();
  delay(5000);

  robotStop();
  delay(1000);

  // --- نمایش مانورهای اضافی ---

  // 5. چرخش ساعتگرد برای 3 ثانیه
  rotateClockwise();
  delay(3000);

  robotStop();
  delay(1000);

  // 6. چرخش پادساعتگرد برای 3 ثانیه
  rotateCounterClockwise();
  delay(3000);

  // توقف نهایی قبل از تکرار حلقه
  robotStop();
  delay(5000);
}
```

## بخش ۴: کد کامل برنامه (آماده برای اجرا)

در زیر، کد کامل و یکپارچه شده که آماده کپی، کامپایل و آپلود روی برد ESP32 شما است، ارائه می‌گردد. این کد شامل تمام بخش‌های بالا به همراه کامنت‌های آموزشی کامل (به زبان فارسی، از طرف استاد) می‌باشد.

```cpp
/*
 * =============================================================================
 * پروژه: کنترل ربات مکانوم چهار چرخ با ESP32 و TB6600
 * راهنما: برای دانشجویان رباتیک و مکاترونیک
 *
 * توضیحات:
 * این برنامه یک ربات چهار چرخ مکانوم را با استفاده از برد ESP32 و چهار
 * درایور استپر موتور TB6600 کنترل می‌کند.
 *
 * معماری کلیدی:
 * این کد از روش سنتی پالس‌دهی نرم‌افزاری (Software Pulsing) که منجر به لرزش
 * و قفل شدن CPU می‌شود، استفاده *نمی‌کند*.
 * به جای آن، ما از واحد سخت‌افزاری LEDC (LED Control) داخلی ESP32 برای
 * تولید سیگنال‌های پالس (PUL) با فرکانس دقیق و پایدار استفاده می‌کنیم.
 *
 * مزیت این روش:
 * 1. پایداری کامل: پالس‌ها توسط سخت‌افزار و بدون هیچ لرزشی (Jitter) تولید می‌شوند.
 * 2. آزادسازی CPU: پردازنده اصلی کاملاً آزاد است و درگیر تولید پالس نمی‌شود.
 * 3. کد ساده: ما می‌توانیم با خیال راحت از تابع delay() در حلقه اصلی (loop)
 * استفاده کنیم، زیرا سخت‌افزار LEDC در پس‌زمینه به کار خود ادامه می‌دهد.
 *
 * (توضیحات): این کد را به دقت مطالعه کنید. به نحوه تعریف پارامترها،
 * پیکربندی سخت‌افزار LEDC در setup() و جداسازی منطق حرکت در توابع مجزا
 * (Abstraction) دقت نمایید.
 * =============================================================================
 */

// --- تعریف پین‌های موتور جلو-راست (FR) ---
#define FR_ENABLE_PIN 32 // پین فعال‌ساز
#define FR_DIR_PIN    33 // پین جهت
#define FR_PULSE_PIN  25 // پین پالس (متصل به کانال LEDC 0)

// --- تعریف پین‌های موتور جلو-چپ (FL) ---
#define FL_ENABLE_PIN 26 // پین فعال‌ساز
#define FL_DIR_PIN    27 // پین جهت
#define FL_PULSE_PIN  13 // پین پالس (متصل به کانال LEDC 1)

// --- تعریف پین‌های موتور عقب-راست (RR) ---
#define RR_ENABLE_PIN 18 // پین فعال‌ساز
#define RR_DIR_PIN    19 // پین جهت
#define RR_PULSE_PIN  21 // پین پالس (متصل به کانال LEDC 2)

// --- تعریف پین‌های موتور عقب-چپ (RL) ---
#define RL_ENABLE_PIN 4  // پین فعال‌ساز
#define RL_DIR_PIN    16 // پین جهت
#define RL_PULSE_PIN  17 // پین پالس (متصل به کانال LEDC 3)

// =============================================================================
// (توضیحات): این بخش برای تنظیم سرعت ربات است.
// =============================================================================

// فرکانس پالس‌ها سرعت موتور را تعیین می‌کند (هرتز یا پالس بر ثانیه).
// برای افزایش سرعت ربات، این عدد را افزایش دهید (مثلاً 4000).
// برای کاهش سرعت ربات، این عدد را کاهش دهید (مثلاً 1000).
#define STEP_FREQUENCY 2000

// =============================================================================
// (توضیحات): این بخش پارامترهای فنی واحد LEDC را تنظیم می‌کند.
// =============================================================================

// رزولوشن تایمر LEDC. 8 بیت به ما بازه 0 تا 255 را برای Duty Cycle می‌دهد.
#define LEDC_TIMER_BITS 8

// ما به یک موج مربعی 50% نیاز داریم. برای رزولوشن 8 بیت، این مقدار 128 می‌شود.
// (1 << (8 - 1)) = (1 << 7) = 128
#define LEDC_DUTY_CYCLE (1 << (LEDC_TIMER_BITS - 1))

// (توضیحات): هر پین پالس باید به یک کانال سخت‌افزاری LEDC مجزا متصل شود.
// ما 4 کانال از 16 کانال موجود را استفاده می‌کنیم.
#define FR_LEDC_CHANNEL 0
#define FL_LEDC_CHANNEL 1
#define RR_LEDC_CHANNEL 2
#define RL_LEDC_CHANNEL 3

// (توضیحات): این تعاریف، کد ما را خواناتر می‌کنند.
// بسته به سیم‌کشی موتور شما، ممکن است لازم باشد این دو را جابجا کنید.
#define FORWARD  HIGH
#define BACKWARD LOW

// =============================================================================
// تابع پیکربندی اولیه (Setup)
// =============================================================================
void setup() {
  // راه‌اندازی ارتباط سریال برای مانیتورینگ و دیباگ
  Serial.begin(115200);
  Serial.println("در حال آماده‌سازی ربات مکانوم...");

  // تنظیم تمام 12 پین کنترلی به عنوان خروجی (OUTPUT)
  pinMode(FR_ENABLE_PIN, OUTPUT);
  pinMode(FR_DIR_PIN, OUTPUT);
  pinMode(FR_PULSE_PIN, OUTPUT);
  
  pinMode(FL_ENABLE_PIN, OUTPUT);
  pinMode(FL_DIR_PIN, OUTPUT);
  pinMode(FL_PULSE_PIN, OUTPUT);
  
  pinMode(RR_ENABLE_PIN, OUTPUT);
  pinMode(RR_DIR_PIN, OUTPUT);
  pinMode(RR_PULSE_PIN, OUTPUT);
  
  pinMode(RL_ENABLE_PIN, OUTPUT);
  pinMode(RL_DIR_PIN, OUTPUT);
  pinMode(RL_PULSE_PIN, OUTPUT);

  // (توضیحات): درایورهای TB6600 معمولاً Active-LOW هستند.
  // یعنی با ارسال سیگنال LOW، درایور *فعال* می‌شود.
  // ما هر چهار درایور را در ابتدای برنامه فعال می‌کنیم.
  digitalWrite(FR_ENABLE_PIN, LOW);
  digitalWrite(FL_ENABLE_PIN, LOW);
  digitalWrite(RR_ENABLE_PIN, LOW);
  digitalWrite(RL_ENABLE_PIN, LOW);

  // --- پیکربندی هسته اصلی: واحد LEDC ---
  
  // (توضیحات): در این 4 خط، ما تایمرهای سخت‌افزاری را پیکربندی می‌کنیم.
  // هر 4 کانال را با فرکانس (سرعت) و رزولوشن یکسان تنظیم می‌کنیم.
  ledcSetup(FR_LEDC_CHANNEL, STEP_FREQUENCY, LEDC_TIMER_BITS);
  ledcSetup(FL_LEDC_CHANNEL, STEP_FREQUENCY, LEDC_TIMER_BITS);
  ledcSetup(RR_LEDC_CHANNEL, STEP_FREQUENCY, LEDC_TIMER_BITS);
  ledcSetup(RL_LEDC_CHANNEL, STEP_FREQUENCY, LEDC_TIMER_BITS);

  // (توضیحات): در این 4 خط، ما هر کانال سخت‌افزاری را به پین فیزیکی
  // مربوط به پالس (PUL) آن موتور متصل (Attach) می‌کنیم.
  ledcAttachPin(FR_PULSE_PIN, FR_LEDC_CHANNEL);
  ledcAttachPin(FL_PULSE_PIN, FL_LEDC_CHANNEL);
  ledcAttachPin(RR_PULSE_PIN, RR_LEDC_CHANNEL);
  ledcAttachPin(RL_PULSE_PIN, RL_LEDC_CHANNEL);
  
  Serial.println("ربات آماده است. شروع سکانس دمو...");
}

// =============================================================================
// توابع کنترلی سطح پایین (Low-Level Control)
// =============================================================================

// (توضیحات): این تابع جهت چرخش هر چهار موتور را تنظیم می‌کند.
// این تابع مستقیماً با پین‌های DIR درایورها صحبت می‌کند.
void setMotorDirections(int frDir, int flDir, int rrDir, int rlDir) {
  digitalWrite(FR_DIR_PIN, frDir);
  digitalWrite(FL_DIR_PIN, flDir);
  digitalWrite(RR_DIR_PIN, rrDir);
  digitalWrite(RL_DIR_PIN, rlDir);
}

// (توضیحات): این تابع به سخت‌افزار LEDC دستور می‌دهد که تولید پالس را
// با Duty Cycle تنظیم شده (128 یا 50%) آغاز کند. این کار موتورها را به حرکت درمی‌آورد.
void activateMotors() {
  ledcWrite(FR_LEDC_CHANNEL, LEDC_DUTY_CYCLE);
  ledcWrite(FL_LEDC_CHANNEL, LEDC_DUTY_CYCLE);
  ledcWrite(RR_LEDC_CHANNEL, LEDC_DUTY_CYCLE);
  ledcWrite(RL_LEDC_CHANNEL, LEDC_DUTY_CYCLE);
}

// (توضیحات): این تابع با ارسال Duty Cycle صفر، تولید پالس را متوقف می‌کند.
// موتورها می‌ایستند. توجه: چون پین EN همچنان LOW است، موتورها
// "گشتاور نگهدارنده" (Holding Torque) خود را حفظ کرده و قفل می‌مانند.
void robotStop() {
  Serial.println("توقف.");
  ledcWrite(FR_LEDC_CHANNEL, 0);
  ledcWrite(FL_LEDC_CHANNEL, 0);
  ledcWrite(RR_LEDC_CHANNEL, 0);
  ledcWrite(RL_LEDC_CHANNEL, 0);
}

// =============================================================================
// توابع حرکتی سطح بالا (High-Level Abstraction)
// (توضیحات): اینها توابعی هستند که شما برای نوشتن مانورهای خود استفاده خواهید کرد.
// این توابع، منطق جدول کینماتیک (جدول ۱ در راهنما) را پیاده‌سازی می‌کنند.
// =============================================================================

// مانور: حرکت مستقیم به جلو
void moveForward() {
  Serial.println("حرکت به جلو...");
  setMotorDirections(FORWARD, FORWARD, FORWARD, FORWARD);
  activateMotors();
}

// مانور: حرکت مستقیم به عقب
void moveBackward() {
  Serial.println("حرکت به عقب...");
  setMotorDirections(BACKWARD, BACKWARD, BACKWARD, BACKWARD);
  activateMotors();
}

// مانور: حرکت جانبی (خرچنگی) به چپ
void strafeLeft() {
  Serial.println("حرکت جانبی به چپ (Strafe Left)...");
  // منطبق بر جدول ۱
  setMotorDirections(BACKWARD, FORWARD, FORWARD, BACKWARD);
  activateMotors();
}

// مانور: حرکت جانبی (خرچنگی) به راست
void strafeRight() {
  Serial.println("حرکت جانبی به راست (Strafe Right)...");
  // منطبق بر جدول ۱
  setMotorDirections(FORWARD, BACKWARD, BACKWARD, FORWARD);
  activateMotors();
}

// مانور: چرخش درجا به صورت ساعتگرد (Clockwise)
void rotateClockwise() {
  Serial.println("چرخش ساعتگرد (CW)...");
  // منطبق بر جدول ۱
  setMotorDirections(FORWARD, BACKWARD, FORWARD, BACKWARD);
  activateMotors();
}

// مانور: چرخش درجا به صورت پادساعتگرد (Counter-Clockwise)
void rotateCounterClockwise() {
  Serial.println("چرخش پادساعتگرد (CCW)...");
  // منطبق بر جدول ۱
  setMotorDirections(BACKWARD, FORWARD, BACKWARD, FORWARD);
  activateMotors();
}

// =============================================================================
// حلقه اصلی برنامه (Loop)
// (توضیحات): در اینجا ما سکانس نمایشی را اجرا می‌کنیم.
// توجه کنید که استفاده از delay() کاملاً امن است، زیرا سخت‌افزار LEDC
// در پس‌زمینه به کار خود ادامه می‌دهد و حرکت ربات متوقف یا لرزان نمی‌شود.
// =============================================================================
void loop() {
  
  Serial.println("--- شروع دور جدید دمو ---");

  // 1. حرکت به جلو برای 5 ثانیه
  moveForward();
  delay(5000);

  // توقف 1 ثانیه‌ای بین مانورها
  robotStop();
  delay(1000);

  // 2. حرکت به عقب برای 5 ثانیه
  moveBackward();
  delay(5000);

  robotStop();
  delay(1000);

  // 3. حرکت جانبی به چپ برای 5 ثانیه
  strafeLeft();
  delay(5000);

  robotStop();
  delay(1000);

  // 4. حرکت جانبی به راست برای 5 ثانیه
  strafeRight();
  delay(5000);

  robotStop();
  delay(1000);

  // --- نمایش مانورهای اضافی ---

  // 5. چرخش ساعتگرد برای 3 ثانیه
  rotateClockwise();
  delay(3000);

  robotStop();
  delay(1000);

  // 6. چرخش پادساعتگرد برای 3 ثانیه
  rotateCounterClockwise();
  delay(3000);

  // توقف طولانی‌تر (5 ثانیه) قبل از تکرار کل سکانس
  robotStop();
  delay(5000);
}
```

## بخش ۵: راهنمای دانشجویان: چگونه ربات خود را سفارشی کنید؟

این کد، نقطه شروعی قدرتمند برای شماست. در ادامه به چند سوال رایج برای سفارشی‌سازی ربات پاسخ داده شده است.

**س: چگونه می‌توانم سرعت ربات را تغییر دهم؟**

ج: بسیار ساده است. به بالای کد (بخش Header) بروید و مقدار ثابت `STEP_FREQUENCY` را تغییر دهید. این مقدار، فرکانس پالس‌های ارسالی به هر چهار موتور است.

`#define STEP_FREQUENCY 1000` (ربات آهسته‌تر حرکت می‌کند)
`#define STEP_FREQUENCY 4000` (ربات سریع‌تر حرکت می‌کند)

توجه: مراقب محدودیت‌های مکانیکی موتورهای گیربکس خود باشید. اگر فرکانس را بیش از حد بالا ببرید، ممکن است موتور "گام گم کند" (Lose Steps) و گشتاور خود را از دست بدهد.

**س: چگونه ربات را به صورت مورب (Diagonal) حرکت دهم؟**

ج: عالی! این نشان می‌دهد که کینماتیک را درک کرده‌اید. برای حرکت مورب (مثلاً جلو-راست)، شما فقط باید دو موتور قطری را فعال کنید.
یک تابع جدید به این شکل بنویسید:

```cpp
// مانور: حرکت مورب به سمت جلو-راست
void moveDiagonalForwardRight() {
  Serial.println("حرکت مورب (جلو-راست)...");
  // 1. جهت‌ها را تنظیم کن (فقط FL و RR به جلو)
  setMotorDirections(FORWARD, FORWARD, FORWARD, FORWARD); // جهت مهم نیست چون 2 تا خاموشند

  // 2. فقط موتورهای مورد نظر را فعال کن
  ledcWrite(FL_LEDC_CHANNEL, LEDC_DUTY_CYCLE); // جلو-چپ روشن
  ledcWrite(RR_LEDC_CHANNEL, LEDC_DUTY_CYCLE); // عقب-راست روشن

  // 3. دو موتور دیگر را حتماً خاموش کن
  ledcWrite(FR_LEDC_CHANNEL, 0); // جلو-راست خاموش
  ledcWrite(RL_LEDC_CHANNEL, 0); // عقب-چپ خاموش
}
```

سپس این تابع جدید را در `loop()` خود فراخوانی کنید.

**س: تفاوت `robotStop()` و غیرفعال کردن پین `EN` چیست؟**

ج: این یک سوال فنی بسیار مهم است.

* **`robotStop()`** (که `ledcWrite(channel, 0)` را اجرا می‌کند): پالس‌ها را متوقف می‌کند، اما پین `EN` همچنان `LOW` است. این یعنی درایور فعال است و به موتورها جریان می‌فرستد تا موقعیت فعلی خود را حفظ کنند. این حالت "گشتاور نگهدارنده" (Holding Torque) نام دارد و برای زمانی که می‌خواهید ربات در یک شیب بایستد، ایده‌آل است. اما این کار مصرف انرژی داشته و باعث گرم شدن موتورها می‌شود.
* **`digitalWrite(FR_ENABLE_PIN, HIGH);`** (و برای سایر پین‌های `EN`): این کار درایور را کاملاً غیرفعال می‌کند. جریان ارسالی به موتور قطع شده و شفت موتور آزادانه می‌چرخد. این حالت برای صرفه‌جویی در انرژی و کاهش گرما عالی است، اما ربات گشتاور نگهدارنده خود را از دست داده و ممکن است حرکت کند.

**چالش‌ها برای دانشجویان:**

1.  **حرکت ترکیبی (مانور پیشرفته):** تابعی بنویسید که ربات را همزمان که به جلو می‌رود، کمی هم به چپ حرکت دهد (ترکیب Forward و Strafe). (راهنمایی: این کار نیازمend آن است که سرعت موتورها متفاوت باشد. شما باید فرکانس (`STEP_FREQUENCY`) را برای کانال‌های `LEDC` مختلف، به صورت متفاوت تنظیم کنید. این کار با فراخوانی مجدد `ledcSetup` یا `ledcChangeFrequency` (در ESP-IDF) امکان‌پذیر است).
2.  **کنترل پیشرفته (Real-Time):** این پروژه را با استفاده از `FreeRTOS` (سیستم‌عامل داخلی ESP32) بازنویسی کنید. یک `Task` مجزا در هسته دوم برای دریافت دستورات از Serial Monitor (مثلاً 'w' برای جلو، 'a' برای چپ) ایجاد کنید تا بتوانید ربات را به صورت زنده و بدون `delay()` کنترل کنید. (این چالش به شما نشان می‌دهد که چرا راه‌حل `LEDC` که ما استفاده کردیم، برای شروع انقدر هوشمندانه و ساده است).

## بخش ۶: نتیجه‌گیری و منابع

در این گزارش، ما با موفقیت یک سیستم کنترلی قوی، پایدار و بدون لرزش را برای یک ربات مکانوم چهار چرخ، با استفاده از میکروکنترلر ESP32 و درایورهای TB6600 پیاده‌سازی کردیم.

دستاورد کلیدی این پروژه، انتخاب معماری نرم‌افزاری هوشمندانه بود. با بهره‌گیری و تغییر کاربری واحد سخت‌افزاری `LEDC`، ما توانستیم چالش اصلی کنترل همزمان استپرها را حل کنیم. این رویکرد به ما اجازه داد تا ضمن دستیابی به عملکردی بی‌نقص و دقیق در سطح سخت‌افزار، کدی بسیار ساده، خوانا و آموزشی در سطح نرم‌افزار داشته باشیم که حتی با وجود استفاده از توابع `delay()`، عملکرد آن مختل نمی‌شود.

کد ارائه‌شده در این راهنما، یک پایه تمیز، قابل اعتماد و قابل توسعه است. دانشجویان می‌توانند با اطمینان از پایداری لایه‌های زیرین، بر روی توسعه منطق حرکتی پیچیده‌تر، مانند ناوبری خودران، پیاده‌سازی الگوریتم‌های `SLAM`، یا افزودن کنترل از راه دور (مانند جوی‌استیک یا Wi-Fi) تمرکز کنند.

**منابع برای مطالعه بیشتر:**

1.  \[1]: مستندات رسمی Espressif در مورد واحد جانبی LEDC.
2.  \[2]: مقالات و راهنماهای عالی در مورد کینماتیک و اصول حرکت چرخ‌های مکانوم.
3.  \[3]: راهنماهای فنی در مورد کار با درایور استپر موتور TB6600.
